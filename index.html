<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ảnh trên Màn hình LED</title>
    
    <!-- Tải Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tải các thư viện phụ trợ TRƯỚC React -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://unpkg.com/gifuct-js/dist/gifuct-js.min.js"></script>
    
    <!-- Tải React và ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Tải Babel để chuyển đổi JSX trong trình duyệt -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tải font Inter từ Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        /* Áp dụng font Inter cho toàn bộ trang */
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-900">
    <!-- Phần tử gốc để React render ứng dụng vào -->
    <div id="root"></div>

    <!-- Mã React của bạn sẽ được đặt ở đây -->
    <script type="text/babel">
        // Import các hook cần thiết từ React
        const { useState, useRef, useEffect, useCallback } = React;

        const App = () => {
            const [imageSrc, setImageSrc] = useState(null);
            const [ledGrid, setLedGrid] = useState([]);
            const [density, setDensity] = useState('medium');
            const [aspectRatio, setAspectRatio] = useState('1 / 1');
            const [isSaving, setIsSaving] = useState(false);
            
            // State và Ref cho việc xử lý GIF
            const [isGif, setIsGif] = useState(false);
            const [isPlaying, setIsPlaying] = useState(false);
            const animationFrameId = useRef(null);
            const gifFramesRef = useRef([]);
            const currentFrameIndexRef = useRef(0);
            const lastFrameTimeRef = useRef(0);
            const gifCanvasRef = useRef(null); // Canvas riêng để vẽ các khung hình GIF

            const fileInputRef = useRef(null);
            const displayContainerRef = useRef(null);

            // Cài đặt mật độ điểm ảnh và kích thước lưới
            const DENSITY_SETTINGS = {
                low: { gridSize: 20, dotSize: 16 },
                medium: { gridSize: 40, dotSize: 10 },
                high: { gridSize: 60, dotSize: 6 },
                superHigh: { gridSize: 85, dotSize: 4 },
                extreme: { gridSize: 120, dotSize: 3 },
            };

            const { gridSize, dotSize } = DENSITY_SETTINGS[density];

            // --- HÀM XỬ LÝ LƯỚI LED ---
            const generateLedGridFromCanvas = useCallback(() => {
                if (!gifCanvasRef.current) return;
                const ctx = gifCanvasRef.current.getContext('2d', { willReadFrequently: true });
                const canvasWidth = gifCanvasRef.current.width;
                const canvasHeight = gifCanvasRef.current.height;

                const newLedGrid = [];
                const cellWidth = canvasWidth / gridSize;
                const cellHeight = canvasHeight / gridSize;

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        // **SỬA LỖI TRIỆT ĐỂ:** Lấy màu của pixel ở chính giữa mỗi ô.
                        // Phương pháp này đơn giản và chính xác ở mọi mật độ.
                        const centerX = Math.floor(x * cellWidth + cellWidth / 2);
                        const centerY = Math.floor(y * cellHeight + cellHeight / 2);

                        // Đảm bảo điểm trung tâm nằm trong canvas
                        if (centerX < 0 || centerX >= canvasWidth || centerY < 0 || centerY >= canvasHeight) {
                            newLedGrid.push({ color: 'rgb(0,0,0)', id: `${x}-${y}` });
                            continue;
                        }

                        const imageData = ctx.getImageData(centerX, centerY, 1, 1);
                        const pixel = imageData.data;
                        
                        newLedGrid.push({
                            color: `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`,
                            id: `${x}-${y}`
                        });
                    }
                }
                setLedGrid(newLedGrid);
            }, [gridSize]);

            // --- VÒNG LẶP HOẠT ẢNH GIF ---
            const animateGif = useCallback((timestamp) => {
                if (!isPlaying) return;

                const frames = gifFramesRef.current;
                if (!frames || frames.length === 0) return;

                const currentFrameIndex = currentFrameIndexRef.current;
                const currentFrame = frames[currentFrameIndex];
                
                if (timestamp - lastFrameTimeRef.current > currentFrame.delay) {
                    lastFrameTimeRef.current = timestamp;
                    
                    const canvas = gifCanvasRef.current;
                    const ctx = canvas.getContext('2d');
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    const frameImageData = tempCtx.createImageData(currentFrame.dims.width, currentFrame.dims.height);
                    frameImageData.data.set(currentFrame.patch);
                    tempCtx.putImageData(frameImageData, 0, 0);

                    ctx.drawImage(tempCanvas, currentFrame.dims.left, currentFrame.dims.top);
                    
                    generateLedGridFromCanvas();

                    currentFrameIndexRef.current = (currentFrameIndex + 1) % frames.length;
                }
                
                animationFrameId.current = requestAnimationFrame(animateGif);
            }, [isPlaying, generateLedGridFromCanvas]);

            // --- HÀM XỬ LÝ TẢI LÊN ---
            const handleImageUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // Dừng hoạt ảnh cũ nếu có
                if (animationFrameId.current) {
                    cancelAnimationFrame(animationFrameId.current);
                }
                setIsPlaying(false);
                
                if (file.type === 'image/gif') {
                    setIsGif(true);
                    handleGifUpload(file);
                } else {
                    setIsGif(false);
                    handleStaticImageUpload(file);
                }
            };

            const handleStaticImageUpload = (file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        setAspectRatio(`${img.naturalWidth} / ${img.naturalHeight}`);
                        const canvas = gifCanvasRef.current;
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        generateLedGridFromCanvas();
                    };
                    img.src = e.target.result;
                    setImageSrc(e.target.result);
                };
                reader.readAsDataURL(file);
            };
            
            const handleGifUpload = (file) => {
                if (typeof GIF === 'undefined') {
                    console.error("Lỗi: Thư viện gifuct-js chưa được tải. Vui lòng kiểm tra lại kết nối mạng và thứ tự tải script.");
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const buffer = e.target.result;
                    const gif = new GIF(buffer);
                    const frames = gif.decompressFrames(true);
                    gifFramesRef.current = frames;
                    
                    if(frames.length > 0) {
                        const { width, height } = frames[0].dims;
                        setAspectRatio(`${width} / ${height}`);
                        const canvas = gifCanvasRef.current;
                        canvas.width = width;
                        canvas.height = height;
                        currentFrameIndexRef.current = 0;
                        lastFrameTimeRef.current = 0;
                        setIsPlaying(true);
                    }
                    setImageSrc('gif_loaded'); // Đánh dấu đã tải GIF
                };
                reader.readAsArrayBuffer(file);
            };
            
            // Effect để khởi động/dừng vòng lặp hoạt ảnh
            useEffect(() => {
                if (isPlaying && isGif) {
                    animationFrameId.current = requestAnimationFrame(animateGif);
                } else {
                    if (animationFrameId.current) {
                        cancelAnimationFrame(animationFrameId.current);
                    }
                }
                return () => {
                    if (animationFrameId.current) {
                        cancelAnimationFrame(animationFrameId.current);
                    }
                };
            }, [isPlaying, isGif, animateGif]);
            
            // --- HÀM ĐIỀU KHIỂN & LƯU ---
            const handleButtonClick = () => { fileInputRef.current.click(); };

            const handleSaveImage = () => {
                if (!displayContainerRef.current || !imageSrc || isGif) return;
                setIsSaving(true);
                html2canvas(displayContainerRef.current, { backgroundColor: '#000000', useCORS: true })
                    .then(canvas => {
                        const image = canvas.toDataURL('image/jpeg', 0.9);
                        const link = document.createElement('a');
                        link.href = image;
                        link.download = 'led-art.jpg';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        setIsSaving(false);
                    }).catch(err => {
                        console.error("Oops, something went wrong!", err);
                        setIsSaving(false);
                    });
            };

            const getDensityLabel = (d) => ({ low: 'Thấp', medium: 'TB', high: 'Cao', superHigh: 'S.Cao', extreme: 'Cực Cao' }[d] || '');

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-900 text-white">
                    <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-6">Ảnh trên Màn hình LED</h1>

                    {/* Vùng điều khiển */}
                    <div className="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg w-full max-w-4xl mb-6">
                        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 items-center justify-between">
                            <div className="flex space-x-2 w-full md:w-auto">
                                <button onClick={handleButtonClick} className="w-full py-3 px-6 bg-blue-600 text-white font-bold rounded-lg shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all transform hover:scale-105">
                                    Tải tệp
                                </button>
                                {isGif && (
                                    <button onClick={() => setIsPlaying(!isPlaying)} className="w-full py-3 px-6 bg-teal-600 text-white font-bold rounded-lg shadow-lg hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 transition-all">
                                        {isPlaying ? 'Dừng' : 'Phát'}
                                    </button>
                                )}
                                <button onClick={handleSaveImage} disabled={!imageSrc || isSaving || isGif} className="w-full py-3 px-6 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all transform hover:scale-105 disabled:bg-gray-500 disabled:cursor-not-allowed disabled:transform-none">
                                    {isSaving ? 'Đang lưu...' : 'Lưu ảnh'}
                                </button>
                            </div>
                            <input type="file" accept="image/*" ref={fileInputRef} onChange={handleImageUpload} className="hidden" />
                            <div className="w-full md:w-auto">
                                <div className="flex space-x-1 bg-gray-700 p-1 rounded-lg">
                                    {Object.keys(DENSITY_SETTINGS).map((d) => (
                                        <button key={d} onClick={() => setDensity(d)} className={`w-full sm:w-auto px-3 py-2 text-xs sm:text-sm font-medium rounded-md transition-colors ${density === d ? 'bg-green-500 text-white shadow-md' : 'bg-transparent text-gray-300 hover:bg-gray-600'}`}>
                                            {getDensityLabel(d)}
                                        </button>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Màn hình hiển thị LED */}
                    <div ref={displayContainerRef} className="w-full max-w-4xl bg-black rounded-xl p-4 shadow-lg flex items-center justify-center border-2 border-gray-700 transition-all duration-300" style={{ aspectRatio }}>
                        {imageSrc ? (
                            <div className={`grid ${gridSize >= 60 ? 'gap-[1px]' : 'gap-1'} w-full h-full`} style={{ gridTemplateColumns: `repeat(${gridSize}, 1fr)` }}>
                                {ledGrid.map((dot) => (
                                    <div key={dot.id} className="aspect-square rounded-full flex items-center justify-center" style={{ backgroundColor: dot.color, boxShadow: `0 0 ${dotSize / 2.5}px ${dot.color}, 0 0 ${dotSize / 1.5}px ${dot.color}20` }}>
                                        <div className="w-full h-full rounded-full" style={{ width: `${dotSize}px`, height: `${dotSize}px` }} />
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="text-gray-400 text-lg text-center p-8">
                                <svg xmlns="http://www.w3.org/2000/svg" className="mx-auto h-12 w-12 text-gray-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                </svg>
                                Vui lòng tải lên một bức ảnh hoặc GIF để bắt đầu.
                            </div>
                        )}
                    </div>

                    {/* Canvas ẩn để xử lý ảnh, giờ đây dùng chung cho cả ảnh tĩnh và GIF */}
                    <canvas ref={gifCanvasRef} className="hidden"></canvas>
                </div>
            );
        };

        // **SỬA LỖI:** Chờ cho đến khi toàn bộ trang được tải xong mới khởi tạo React.
        // Điều này đảm bảo các thư viện như 'gifuct-js' đã sẵn sàng để sử dụng.
        window.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('root');
            const root = ReactDOM.createRoot(container);
            root.render(<App />);
        });
    </script>
</body>
</html>
